diff --git a/README.md b/README.md
index 17f9658..230c2c5 100644
--- a/README.md
+++ b/README.md
@@ -1,5 +1,51 @@
+# proot -- Termux の開発コミュニティによる proot の Debian noroot 環境向け修正版
+
+## 概要
+
+この git リポジトリに置かれている [proot][PROT] のソースコードは、 [termux の開発コミュニティ][TERM]による [proot][PROT] のソースコードを、 [Debian noroot 環境][DBNR]上で動作させるように修正したものです。
+
+なお、この git リポジトリに置かれている [proot][PROT] のソースコードをビルドするには、[termux の開発コミュニティによる proot をビルドするための Ruby スクリプト][BLPR]に同梱されている ```build-proot.rb``` を使用して、ビルドを行って下さい。
+
+## Termux の開発コミュニティによる proot のソースコードからの修正点
+
+この git リポジトリに置かれている [proot][PROT] のソースコードは、オリジナルとなる [termux の開発コミュニティ][TERM]による [proot][PROT] のソースコードから、以下の不具合等が修正されています。
+
+- Android NDK の toolchain の他、 PC 上のクロスコンパイル環境においてもビルドが可能となるように修正。
+- VFAT 領域等、シンボリックリンクに対応していないファイルシステムの領域において、システムコール [link(2)][LINK] を実行した時に、リンク元のファイルが別名に変更されたままとなる問題を修正。
+- [proot][PROT] コマンドにおいて、オプション ```--link2symlink``` が指定され、かつ、環境変数 ```PROOT_L2S_DIR``` が設定されない場合に、自動的にオプション ```-H``` が指定されて [proot][PROT] コマンドが起動されるように修正。
+    - また、オプション ```-H``` が設定された場合に、 [proot][PROT] によって不可視化されるファイル及びシンボリックリンクのプレフィックスを ".l2s." とするように修正。
+    - [link(2)][LINK] を [symlink(2)][SLNK] によってエミュレートする機能を使用時に [proot][PROT] の内部で作成される ".l2s." をプレフィックスとするファイル及びシンボリックリンクが外部から直接読み書きが出来るためにこれらのファイルを削除すると、ハードリンクが機能しなくなるために行われる修正です。
+- ソースコード ```src/syscall/socket.c``` において、 obsolete である glibc の標準ライブラリ関数 ```mktemp(3)``` に代えて独自の実装による ```mktemp(3)``` 関数である ```proot_mktemp``` 関数を使用するように修正。
+- ソースコード ```src/cli/proot.c, src/syscall/rlimit.c, src/tracee/mem.c``` 等において、コンパイル時に警告を出力する問題を修正。
+- proot の一時ファイルを置くためのディレクトリのパス名の設定について、環境変数 ```PROOT_TMP_DIR``` の他に、環境変数 ```PROOT_TMPDIR``` を参照するように修正。
+
+## 配布条件
+
+この git リポジトリに置かれている [proot][PROT] のソースコードは、 [termux の開発コミュニティ][TERM]による [proot][PROT] のソースコードを、 [Z.OOL. (mailto:zool@zool.jpn.org)][ZOOL] によって、 [Debian noroot 環境][DBNR]及び PC 上のクロスコンパイル環境においてビルド及び動作するよう修正したものです。
+
+従って、この [proot][PROT] のソースコードは、この git リポジトリに同梱されている [COPYING][COPY] の冒頭に記述されている STMicroelectronics 社の [proot][PROT] の開発者の各氏と [termux の開発コミュニティの各氏][TERM]及び [Z.OOL. (mailto:zool@zool.jpn.org)][ZOOL] が著作権を有し、オリジナルとなる [proot][PROT] のソースコードと同様に、 [GNU public license version 2][GPL2] に従って配布されるものとします。
+
+## 追記
+
+以下に、オリジナルの [proot][PROT] のソースコードの [README.md][READ] の原文を示します。
+
+----
 proot
 =====
 [![Travis build status](https://travis-ci.org/termux/proot.svg?branch=master)](https://travis-ci.org/termux/proot)
 
 This is a copy of [the PRoot project](https://github.com/proot-me/PRoot/) with patches applied to work better under [Termux](https://termux.com).
+
+<!-- 外部リンク一覧 -->
+
+[TERM]:https://termux.com/
+[DBNR]:https://play.google.com/store/apps/details?id=com.cuntubuntu&hl=ja
+[BLPR]:https://github.com/z80oolong/proot-termux-build
+[LINK]:http://man7.org/linux/man-pages/man2/link.2.html
+[SLNK]:http://man7.org/linux/man-pages/man2/symlink.2.html
+[PROT]:https://github.com/termux/proot
+[TMRP]:https://github.com/termux
+[ZOOL]:http://zool.jpn.org/
+[COPY]:https://github.com/z80oolong/proot/blob/master/COPYING
+[GPL2]:https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html
+[READ]:https://github.com/termux/proot/blob/master/README.md
diff --git a/src/arch.h b/src/arch.h
index f554338..272bcbe 100644
--- a/src/arch.h
+++ b/src/arch.h
@@ -111,6 +111,22 @@ typedef unsigned char byte_t;
     #undef SYSCALL_AVOIDER
     #define SYSCALL_AVOIDER ((word_t) 222)
 
+    #if !defined(__ANDROID__) && defined(__thumb__)
+    /* Fix a compile error of proot when edc869d -> 58d2161. */
+    /* These defines come from /usr/arm-linux-gnueabihf/include/asm/ptrace.h */
+    #ifndef ARM_cpsr
+    #define ARM_cpsr        uregs[16]
+    #endif /* ARM_cpsr */
+
+    #ifndef V4_PSR_T_BIT
+    #define V4_PSR_T_BIT    0x00000020      /* >= V4T, but not V7M */
+    #endif /* V4_PSR_T_BIT */
+
+    #ifndef PSR_T_BIT
+    #define PSR_T_BIT       V4_PSR_T_BIT
+    #endif /* PSR_T_BIT */
+    #endif /* !__ANDROID__ && __thumb__ */
+
 #elif defined(ARCH_ARM64)
 
     #define SYSNUMS_HEADER1 "syscall/sysnums-arm64.h"
@@ -139,6 +155,35 @@ typedef unsigned char byte_t;
     #undef SYSCALL_AVOIDER
     #define SYSCALL_AVOIDER ((word_t) -1)
 
+    #ifndef __ANDROID__
+    /* Fix a compile error of proot when using aarch64-linux-gnu-gcc. */
+    /* These define come from glibc/sysdeps/unix/sysv/linux/aarch64/sys/user.h */
+    /* See https://code.woboq.org/userspace/glibc//sysdeps/unix/sysv/linux/aarch64/sys/user.h.html */
+    #include <stdint.h>
+
+    struct user_regs_struct {
+	    uint64_t regs[31];
+	    uint64_t sp;
+	    uint64_t pc;
+	    uint64_t pstate;
+    };
+
+    struct user_fpsimd_struct {
+	    __uint128_t vregs[32];
+	    uint32_t fpsr;
+	    uint32_t fpcr;
+    };
+    #endif /* __ANDROID__ */
+
+    /* This define come from /usr/src/include/uapi/linux/ptrace.h */
+    /* See https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/ptrace.h */
+    #ifndef PTRACE_GETSIGMASK
+    #define PTRACE_GETSIGMASK	0x420a
+    #endif
+    #ifndef PTRACE_SETSIGMASK
+    #define PTRACE_SETSIGMASK	0x420b
+    #endif
+
 #elif defined(ARCH_X86)
 
     #define SYSNUMS_HEADER1 "syscall/sysnums-i386.h"
diff --git a/src/cli/cli.c b/src/cli/cli.c
index c523f2e..e3949ee 100644
--- a/src/cli/cli.c
+++ b/src/cli/cli.c
@@ -557,10 +557,17 @@ const char *expand_front_variable(TALLOC_CTX *context, const char *string)
 
 static int indent_level = 0;
 
+#ifdef __ANDROID__
+void __cyg_profile_func_enter(void *this_function UNUSED, void *call_site UNUSED) DONT_INSTRUMENT;
+void __cyg_profile_func_enter(void *this_function UNUSED, void *call_site UNUSED)
+#else
 void __cyg_profile_func_enter(void *this_function, void *call_site) DONT_INSTRUMENT;
 void __cyg_profile_func_enter(void *this_function, void *call_site)
+#endif
 {
+#ifndef __ANDROID__
 	void *const pointers[] = { this_function, call_site };
+#endif
 	char **symbols = NULL;
 
 #ifndef __ANDROID__
diff --git a/src/cli/proot.c b/src/cli/proot.c
index 6a37c79..1f29a44 100644
--- a/src/cli/proot.c
+++ b/src/cli/proot.c
@@ -221,8 +221,10 @@ static int handle_option_V(Tracee *tracee UNUSED, const Cli *cli, const char *va
 	fflush(stdout);
 
 	size = &_binary_licenses_end - &_binary_licenses_start;
-	if (size > 0)
-		write(1, &_binary_licenses_start, size);
+	if (size > 0) {
+		if (write(1, &_binary_licenses_start, size) < 0) { /* noop */
+		}
+	}
 
 	exit_failure = false;
 	return -1;
@@ -283,12 +285,20 @@ static int handle_option_S(Tracee *tracee, const Cli *cli, const char *value)
 static int handle_option_link2symlink(Tracee *tracee, const Cli *cli UNUSED, const char *value UNUSED)
 {
 	int status;
+	char *l2s_directory;
 
 	/* Initialize the link2symlink extension.  */
 	status = initialize_extension(tracee, link2symlink_callback, NULL);
 	if (status < 0)
 		note(tracee, WARNING, INTERNAL, "link2symlink not initialized");
 
+	/* If environment variable PROOT_L2S_DIR is not set, the option "-H" is forced to be set. */
+	l2s_directory = getenv("PROOT_L2S_DIR");
+	if (l2s_directory == NULL || l2s_directory[0] == '\0') {
+		if(handle_option_H(tracee, cli, value) < 0) { /* noop */
+		}
+	}
+
 	return 0;
 }
 
diff --git a/src/cli/proot.h b/src/cli/proot.h
index 31ce9ac..bccaafb 100644
--- a/src/cli/proot.h
+++ b/src/cli/proot.h
@@ -245,7 +245,12 @@ Copyright (C) 2015 STMicroelectronics, licensed under GPL v2 or later.",
                 { .name = "-H", .separator = '\0', .value = NULL },
                 { .name = NULL, .separator = '\0', .value = NULL } },
           .handler = handle_option_H,
+#ifdef USERLAND
           .description = "Hide files and directories starting with '.proot.' .",
+#endif
+#ifndef USERLAND
+          .description = "Hide files and directories starting with '.l2s.' . (If environment variable 'PROOT_L2S_DIR' is not set, this option is forced to be set.)",
+#endif
           .detail = "",
         },
         { .class = "Extension options",
diff --git a/src/extension/fake_id0/chroot.c b/src/extension/fake_id0/chroot.c
index 757a602..1876d13 100644
--- a/src/extension/fake_id0/chroot.c
+++ b/src/extension/fake_id0/chroot.c
@@ -32,12 +32,14 @@ int handle_chroot_exit_end(Tracee *tracee, Config *config) {
 	status = translate_path(tracee, path_translated, AT_FDCWD, path, false);
 	if (status < 0)
 		return status;
-	realpath(path_translated, path_translated_absolute);
+	if (realpath(path_translated, path_translated_absolute) == (char *)NULL) { /* noop */
+	}
 
 	status = translate_path(tracee, root_translated, AT_FDCWD, get_root(tracee), false);
 	if (status < 0)
 		return status;
-	realpath(root_translated, root_translated_absolute);
+	if (realpath(root_translated, root_translated_absolute) == (char *)NULL) { /* noop */
+	}
 
 	/* Only "new rootfs == current rootfs" is supported yet.  */
 	status = compare_paths(root_translated_absolute, path_translated_absolute);
diff --git a/src/extension/fake_id0/fake_id0.c b/src/extension/fake_id0/fake_id0.c
index 0e248e3..886c483 100644
--- a/src/extension/fake_id0/fake_id0.c
+++ b/src/extension/fake_id0/fake_id0.c
@@ -1082,6 +1082,7 @@ int fake_id0_callback(Extension *extension, ExtensionEvent event, intptr_t data1
 			uid = getuid();
 
 		gid_string = strchr(uid_string, ':');
+		gid = 0;
 		if (gid_string == NULL) {
 			errno = EINVAL;
 		}
diff --git a/src/extension/fake_id0/helper_functions.c b/src/extension/fake_id0/helper_functions.c
index 3a16ce5..48c4e97 100644
--- a/src/extension/fake_id0/helper_functions.c
+++ b/src/extension/fake_id0/helper_functions.c
@@ -319,7 +319,8 @@ int read_meta_file(char path[PATH_MAX], mode_t *mode, uid_t *owner, gid_t *group
 		return 0;
 
 	}
-	fscanf(fp, "%d %d %d ", &lcl_mode, owner, group);
+	if (fscanf(fp, "%d %d %d ", &lcl_mode, owner, group) == EOF) { /* noop */
+	}
 	lcl_mode = otod(lcl_mode);
 	*mode = (mode_t)lcl_mode;
 	fclose(fp);
diff --git a/src/extension/fake_id0/sendmsg.c b/src/extension/fake_id0/sendmsg.c
index 228fcdc..ea3cb8d 100644
--- a/src/extension/fake_id0/sendmsg.c
+++ b/src/extension/fake_id0/sendmsg.c
@@ -13,7 +13,7 @@ int handle_sendmsg_enter_end(Tracee *tracee, word_t sysnum)
 	/* Read sendmsg header.  */
 	int status;
 	unsigned long socketcall_args[3];
-	struct msghdr msg = {};
+	struct msghdr msg = { .msg_name = (void *)NULL };
 	bool is_socketcall = sysnum == PR_socketcall;
 
 	if (!is_socketcall)
diff --git a/src/extension/hidden_files/hidden_files.c b/src/extension/hidden_files/hidden_files.c
index 54e4abc..a27a42b 100644
--- a/src/extension/hidden_files/hidden_files.c
+++ b/src/extension/hidden_files/hidden_files.c
@@ -13,7 +13,12 @@
 #include "path/path.h"
 
 /* Change the HIDDEN_PREFIX to change which files are hidden */
+#ifdef USERLAND
 #define HIDDEN_PREFIX ".proot"
+#endif 
+#ifndef USERLAND
+#define HIDDEN_PREFIX ".l2s."
+#endif 
 
 struct linux_dirent {
     unsigned long d_ino;
diff --git a/src/extension/link2symlink/link2symlink.c b/src/extension/link2symlink/link2symlink.c
index 3b63382..511cc22 100644
--- a/src/extension/link2symlink/link2symlink.c
+++ b/src/extension/link2symlink/link2symlink.c
@@ -56,6 +56,8 @@ static int move_and_symlink_path(Tracee *tracee, Reg sysarg)
 	char new_intermediate[PATH_MAX];
 	char final[PATH_MAX];
 	char new_final[PATH_MAX];
+	char final_bak[PATH_MAX];
+	char intermediate_bak[PATH_MAX];
 	char * name;
 	const char * l2s_directory;
 	struct stat statl;
@@ -141,13 +143,24 @@ static int move_and_symlink_path(Tracee *tracee, Reg sysarg)
 
 		/* Symlink the intermediate to the final file.  */
 		status = symlink(final, intermediate);
-		if (status < 0)
+		if (status < 0) {
+			/* ensure rename final -> original */
+			rename(final, original);
+
 			return status;
+		}
 
 		/* Symlink the original path to the intermediate one.  */
 		status = symlink(intermediate, original);
-		if (status < 0)
+		if (status < 0) {
+			/* ensure rename final -> original */
+			rename(final, original);
+
+			/* ensure unlink intermediate */
+			unlink(intermediate);
+
 			return status;
+		}
 	} else {
 		/*Move the original content to new location, by incrementing count at end of path. */
 		size = my_readlink(intermediate, final);
@@ -166,12 +179,32 @@ static int move_and_symlink_path(Tracee *tracee, Reg sysarg)
 		status = notify_extensions(tracee, LINK2SYMLINK_RENAME, (intptr_t) final, (intptr_t) new_final);
 		if (status < 0)
 			return status;
+
+		strcpy(final_bak, final);
 		strcpy(final, new_final);
+		snprintf(intermediate_bak, (size_t)PATH_MAX, "%s.bak", intermediate);
+
 		/* Symlink the intermediate to the final file.  */
-		status = unlink(intermediate);
-		if (status < 0)
+		status = rename(intermediate, intermediate_bak);
+		if (status < 0) {
+			/* ensure rename final_bak (original final) -> final */
+			rename(final, final_bak);
+
 			return status;
+		}
+
 		status = symlink(final, intermediate);
+		if (status < 0) {
+			/* ensure rename intermediate_bak (original intermediate) -> intermediate */
+			rename(intermediate_bak, intermediate);
+
+			/* ensure rename final_bak (original final) -> final */
+			rename(final, final_bak);
+
+			return status;
+		}
+
+		status = unlink(intermediate_bak);
 		if (status < 0)
 			return status;
 	}
@@ -195,6 +228,8 @@ static int decrement_link_count(Tracee *tracee, Reg sysarg)
 	char intermediate[PATH_MAX];
 	char final[PATH_MAX];
 	char new_final[PATH_MAX];
+	char final_bak[PATH_MAX];
+	char intermediate_bak[PATH_MAX];
 	char * name;
 	struct stat statl;
 	ssize_t size;
@@ -254,15 +289,32 @@ static int decrement_link_count(Tracee *tracee, Reg sysarg)
 		if (status < 0)
 			return status;
 
+		strcpy(final_bak, final);
 		strcpy(final, new_final);
+		snprintf(intermediate_bak, (size_t)PATH_MAX, "%s.bak", intermediate);
 
 		/* Symlink the intermediate to the final file.  */
-		status = unlink(intermediate);
-		if (status < 0)
+		status = rename(intermediate, intermediate_bak);
+		if (status < 0) {
+			/* ensure final_bak (original final) -> final */
+			rename(final_bak, final);
+
 			return status;
+		}
 
 		status = symlink(final, intermediate);
-		if (status < 0)
+		if (status < 0) {
+			/* ensure final_bak (original final) -> final */
+			rename(final_bak, final);
+
+			/* ensure intermediate_bak (original intermediate) -> intermediate */
+			rename(intermediate_bak, intermediate);
+
+			return status;
+		}
+
+		status = unlink(intermediate_bak);
+		if(status < 0)
 			return status;
 	} else {
 		/* If it is the last, delete the intermediate and final */
diff --git a/src/path/temp.c b/src/path/temp.c
index 8d8aa63..829168a 100644
--- a/src/path/temp.c
+++ b/src/path/temp.c
@@ -24,7 +24,11 @@ const char *get_temp_directory()
 
 	temp_directory = getenv("PROOT_TMP_DIR");
 	if (temp_directory == NULL) {
-		temp_directory = P_tmpdir;
+		temp_directory = getenv("PROOT_TMPDIR");
+		if (temp_directory == NULL) {
+			temp_directory = P_tmpdir;
+			return temp_directory;
+		}
 	}
 
 	tmp = realpath(temp_directory, NULL);
diff --git a/src/syscall/rlimit.c b/src/syscall/rlimit.c
index d167843..27efd2a 100644
--- a/src/syscall/rlimit.c
+++ b/src/syscall/rlimit.c
@@ -88,7 +88,7 @@ int translate_setrlimit_exit(const Tracee *tracee, bool is_prlimit)
 		/* Convert this special value from 32-bit to 64-bit,
 		 * if needed.  */
 		if (is_32on64_mode(tracee) && tracee_stack_limit == (uint32_t) -1)
-			tracee_stack_limit = RLIM_INFINITY;
+			tracee_stack_limit = (uint32_t)RLIM_INFINITY;
 	}
 	if (errno != 0)
 		return -errno;
@@ -112,6 +112,6 @@ int translate_setrlimit_exit(const Tracee *tracee, bool is_prlimit)
 		VERBOSE(tracee, 1, "can't set stack limit.");
 	return 0; /* Not fatal.  */
 
-	VERBOSE(tracee, 1, "stack soft limit increased to %llu bytes", proot_stack.rlim_cur);
+	VERBOSE(tracee, 1, "stack soft limit increased to %llu bytes", (long long unsigned int)proot_stack.rlim_cur);
 	return 0;
 }
diff --git a/src/syscall/socket.c b/src/syscall/socket.c
index ec74950..6780318 100644
--- a/src/syscall/socket.c
+++ b/src/syscall/socket.c
@@ -28,6 +28,10 @@
 #include <sys/socket.h>  /* struct sockaddr_un, AF_UNIX, */
 #include <sys/un.h>      /* struct sockaddr_un, */
 #include <sys/param.h>   /* MIN(), MAX(), */
+#include <stdlib.h>      /* For proot_mktemp() */
+#include <time.h>        /* For proot_mktemp() */
+#include <sys/types.h>   /* For proot_mktemp() */
+#include <sys/stat.h>    /* For proot_mktemp() */
 
 #include "syscall/socket.h"
 #include "tracee/tracee.h"
@@ -39,12 +43,47 @@
 
 #include "compat.h"
 
+/* For proot_mktemp() */
+#define ALPHABET "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
+#define XXXXXX "XXXXXX"
+
 /* The sockaddr_un structure has exactly the same layout on all
  * architectures.  */
 static const off_t offsetof_path = offsetof(struct sockaddr_un, sun_path);
 extern struct sockaddr_un sockaddr_un__;
 static const size_t sizeof_path  = sizeof(sockaddr_un__.sun_path);
 
+/**
+ * This function generates a unique temporary filename from @path.
+ * The last six characters of @path must be XXXXXX and these 
+ * are replaced with a string that makes the filename unique. 
+ * The function proot_mktemp() is made instead of mktemp(3) in glibc.
+ */
+static char *proot_mktemp(char *path) {
+	char *xptr, *p; struct stat st;
+
+	xptr = strstr((const char *)path, XXXXXX);
+
+	if ((xptr == (char *)NULL) || (*(xptr + strlen(XXXXXX)) != '\0')) {
+		(void)strncpy(path, "", strlen((const char *)path));
+		return (char *)NULL;
+	}
+
+	srand((unsigned int)time(NULL));
+
+	for ( ; ; ) {
+		for (p = xptr ; *p == 'X'; p++) {
+			*p = ALPHABET[rand() % strlen(ALPHABET)];
+		}
+
+		if (stat(path, &st) == -1) {
+			return path;
+		} else {
+			(void)strncpy(xptr, XXXXXX, strlen(XXXXXX));
+		}
+	}
+}
+
 /**
  * Copy in @sockaddr the struct sockaddr_un stored in the @tracee
  * memory at the given @address.  Also, its pathname is copied to the
@@ -120,7 +159,7 @@ int translate_socketcall_enter(Tracee *tracee, word_t *address, int size)
 		if (shorter_host_path == NULL || strlen(shorter_host_path) > sizeof_path)
 			return -EINVAL;
 
-		(void) mktemp(shorter_host_path);
+		(void) proot_mktemp(shorter_host_path);
 
 		if (strlen(shorter_host_path) > sizeof_path)
 			return -EINVAL;
diff --git a/src/tracee/event.c b/src/tracee/event.c
index 7310605..501baee 100644
--- a/src/tracee/event.c
+++ b/src/tracee/event.c
@@ -637,7 +637,7 @@ int handle_tracee_event(Tracee *tracee, int tracee_status)
 			break;
 
 		case SIGSYS: {
-			siginfo_t siginfo = {};
+			siginfo_t siginfo = { .si_signo = 0 };
 			ptrace(PTRACE_GETSIGINFO, tracee->pid, NULL, &siginfo);
 			if (siginfo.si_code == SYS_SECCOMP) {
 				if (tracee->skip_next_seccomp_signal) {
diff --git a/src/tracee/mem.c b/src/tracee/mem.c
index 5e0d1d9..0aadd68 100644
--- a/src/tracee/mem.c
+++ b/src/tracee/mem.c
@@ -192,14 +192,14 @@ static int ptrace_pokedata_or_via_stub(Tracee *tracee, word_t addr, word_t word)
 	return status;
 }
 
-void mem_prepare_after_execve(Tracee *tracee)
+void mem_prepare_after_execve(Tracee *tracee UNUSED)
 {
 #if HAS_POKEDATA_WORKAROUND
 	tracee->pokedata_workaround_stub_addr = peek_reg(tracee, CURRENT, INSTR_POINTER) + offset_to_pokedata_workaround;
 #endif
 }
 
-void mem_prepare_before_first_execve(Tracee *tracee)
+void mem_prepare_before_first_execve(Tracee *tracee UNUSED)
 {
 #if HAS_POKEDATA_WORKAROUND
 	tracee->pokedata_workaround_stub_addr = (word_t)&launcher_pokedata_workaround;
diff --git a/src/tracee/reg.c b/src/tracee/reg.c
index 4c8d254..986e6e6 100644
--- a/src/tracee/reg.c
+++ b/src/tracee/reg.c
@@ -262,7 +262,11 @@ int fetch_regs(Tracee *tracee)
 	return 0;
 }
 
+#ifdef ARCH_ARM_EABI
 int push_specific_regs(Tracee *tracee, bool including_sysnum)
+#else
+int push_specific_regs(Tracee *tracee, bool including_sysnum UNUSED)
+#endif
 {
 	int status;
 
diff --git a/src/tracee/seccomp.c b/src/tracee/seccomp.c
index 7a3893e..1fa186a 100644
--- a/src/tracee/seccomp.c
+++ b/src/tracee/seccomp.c
@@ -230,7 +230,6 @@ static int handle_seccomp_event_common(Tracee *tracee)
 	case PR_statfs:
 	{
 		int size;
-		int status;
 		char path[PATH_MAX];
 		char original[PATH_MAX];
 		struct statfs64 my_statfs64;
